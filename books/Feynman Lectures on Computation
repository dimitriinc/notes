ONE: INTRODUCTION TO COMPUTERS

Computer science is not a science in the general sense of the word, as it doesn't describe nature; it's closer to engineering as it deals primary with performing practical tasks. However, to accomplish its goals, CS deploys a lot of theoretical knowledge, and produces a lot of insights on the actual sciences, e.g. linguistics.
All computers share basic structure and functionality on the core level. Just like language is theoretically expressible with different symbol systems of varying complexity (the less comlex a symbol system is, the more individual symbols will be needed to express an idea); a task performed by a sofisticated computer A, can be performed by a cruder computer B, it will just take more resources (e.g. time, power, hardware, etc.); - this principle is called "universality". In other terms, any complex instruction can be built from a set of simple ("least sufficient") instructions.
To perform a complex task we need a sequence of precise instructions (software) and a machine capable of carrying out those instructions in the specified order (hardware).
A computer provides us with a set of rudimentary instructions, using which we can build more and more complex instructions, abstracting away cruder ones, going up the abstraction levels, all the way from electronic circuitry to operating systems' system calls.
In this lecutre we start by constructing a set of primitive procedures: how to add two numbers or move numbers from one place to another, and go a little further to a bit more complex procedures, like multipling two numbers. We'll discuss only computers of the Von Neumann architecture (the way electronic components are arranged) and only ones that perform tasks in sequential manner, since the parallel processing doesn't add anything on the basic principles level, only speed.
Although the machine is called a "computer", computing (like in arithmetics) is not the task it mostly does; and it's reflected in the architecture - only one component is resonsible for arithmetic operations, the vast majority of the system is dedicated to moving data: control, transportation, storage, etc. The operations it does most of the time are those akin to beaurocratic clerks operating on paper files, only in our case those papers are digital electrical signals.
We stay with this metaphor for a bit longer.

--- The File Clerk Model ---

We have a clerk, who is stupid and devoid of will, i.e. he can perform only a set of simple operations, and he can't do anything without us saying him to do it. He has a cabinet full of cards, and on those cards there is some business-relatied information. E.g. there are cards about sales, a card for each sale. On one card there will be a name of the salesperson, region where the sale happened, transaction value, etc. We can instruct the clerk to count all the sale in the state of California, for that, one of the things he can do is the operation of taking our a card from the cabinet and look at the data stored there; then he will need to find the field related to the state of the sale (in that instruction we can mask the bits related to the state and perform a bitwise AND operation); he will then need to add the value at the state field to a running total value of sales. To keep track of the total value, we could use another card from the cabinet, but for efficiency reasons we can give a small pad to the clerk and he will write down the new value there, and store it on a card in the cabinet only when the whole counting operation is over.
Thus we can perform complex tasks by breaking them down into small ones. And though the clerk is dumb and will not understand the complex operations, he is very fast. He is so fast, that we can't see him running around getting cards and adding numbers, all we can see is complex operations being performed.
