-------------------------------------------------------
CLASSICAL PATTERNS
-------------------------------------------------------


I. GETTING STARTED WITH KOTLIN

	> Kotlin code structure:
	
		- functions doesn't have to be wrapped in a class (like in java), e.g. the main() can exist separately in a file.
		- no 'static' modifier - functions that don't have a state, can be just placed outside of a class
		- params in the main() are optional (in Java String[] args is obligatory)
		
	> Types:
	
		- a type-safe language
		- no distinction between primitive types and object types (in Java 'int' is memory-efficient, while Integer is more operational
		  with its methods and nullable). Kotlin's compiler optimizes the types on the run, not to lose the memory efficiency of a primitive.
		- Java's 'void' is called Unit
		- the type is inferred if not declared explicitly. once declared, the var cannot be assigned a value of a different type.
		
			val greeting: String = "Hello world"

		- mutable variables use the keyword 'var', immutable (aka values) use 'val'. val is preferred - it's easier to reason about the code
		  that way, especially in a concurrent code.
		- '==' is implicitly translated to the equals() (in Java == stands for referential equality, not the equality of the values)
		- if a function returns a value, you should declare its type in the signature, after the params
		
			fun getGreeting(): String {
				return "Hello world"
			}
			
		  if a function consists only of the return statement, you can omit the return type and the curly braces
		  
		  	fun getGreeting() = "Hello world"
		  	
	> Null safety:
	
		- in Java all object types a nullable -> NullPointerException being a big deal
		- in Kotlin types can be nullable (hold '?' after the type) and non-nullable (no '?'), the nullability of types is checked before 
		  compile time
		  
	> Data structures:
	
		- lists: ordered collection of elements of the same type, declared with the listOf()
		- sets: collection of unique elements, not indexed, setOf() return LinkedHashSet. use 'in' function to check the presence of an el
		- maps: collection of key-value pairs, keys are unique. a pair is created with the 'to' special function
		
			val movieBatmans = mapOf(
				"Batman Returns" to "Michael Keaton",
				"Batman Forever" to "Val Kilmer",
				"Batman & Robin" to "George Clooney"
			)
			
		  to access a value by its key, use the bracket notation
		- those are read-only collections, they all have mutable counterparts (e.g. mutableListOf()), where you can use such metods as add()
		- there is also Array<> (the type you pass into the angle brackets is called 'type argument'), used to provide args to the main()
		
			fun main(args: Array<String>) {}
			
		  also to call Java functions that require arrays as args, and while using the 'varargs' syntax.
		  the functionality is similar to lists
		  
	> Control flow:
	
		- 'if' is an expression in Kotlin (statement in Java), which helps us to reduce the amount of return statements and simplify the code
		- 'when' is an analog of 'switch' in Java, but more powerful. also an expression, use when there are multiple conditions.
		
	> Working with text:
	
		- string interpolation - insert a value of a var with $, expression with ${}
		- multiline strings - put them inside """ """, no need to escape quotes, use trimIndent() to get rid of whitespacees and tabs
		
	> Loops:
	
		- for-each - for (element in collection) {}
		- for - the classic 'for' loop in Kotlin is applied to ranges:
		
			for (el in 0..9) {}
			
		  the range is inclusive. you can replace the range operator with the 'until' function, it will be exclusive. to iterate i reverse,
		  replace 'until' with 'downTo' function. the functions like until and downTo are called 'infix call'
		- while - while (expression) {}
		
	> OOP:
	
		- no 'new' keyword, class instantiation: val player = Player()
		- classes can be bodyless
		- primary constructor is defined in parentheses after the class name:
		
			class Player(name: String) {}
			
		- if you add 'val' to the name member, a getter will be automatically generated, and you'll be able to access it via its name:
		
			println(player.name)
			
	          if you add 'var' a setter will be generated along with a getter.
	          a property can be moved inside the body, in this case an initial value must be provided.
	        - you might want to add some validation when setting a new value (i.e. the value can be only positive). to do this you need to declare
	          a custom setter:
	          
	          	class Player(val name: String) {
	          		var score: Int = 0
	          			set(value) {
	          				field = if (value >=0) value else 0
	          			}
	          	}
	          	
	          'value' stands for the new value provided, and 'field' stands for the current value of the property
	        - to provide a custom getter, the property must be declared in the body of the class:
	        
	        	class Player(name: String) {
	        		val name = name
	        			get() = field.toUpperCase()
	        	}
	        	
	        - interfaces are declared with the 'interface' keyword, implemented with a colon:
	        
	        	interface DiceRoller {
	        		fun rollDice(): Int
	        	}
	        	class Player(name: String) : DiceRoller {
	        		fun rollDice() = Random.nextInt(0, 6)
	        	}
	        	
	          interface support default functions, i.e. if a fun doesn't depend on any state, you can define its operation in the body inside
	          the interface.
	        - abstract classes are interfaces that can hold a state. extended with a colon, round brackets after the name:
	        
	        	class Player(name: String) : Moveable(), DiceRoller {}
	        	
	        - by default properties, functions, as well as classes are public
	        - by default all classes are final, i.e. can't be inherited from. to make a class eligable for inheritance, declare it open by 
	          prefixing it with the 'open' modifier.
	        - in the same manner to make functions open to overriding by child classes, you must declare them with the 'open' modifier.
	          to override an open function a child class must use the 'override' keyword
	          private properties cannot be accessed by a child class, they need to be public or protected (visible to the class and its children)
	        - when extending a class (including an abstract class), we should provide data for its constructor (equivalent to calling the super()
	          in Java) 
	          
	          	class ConfusedPlayer(name: String) : Player(name) {}
	          	
	        - data classes replace POJOs of Java, automatically generate equals() and hashCode(). are always final (can't be extended), though
	          can inherit from other classes. have a copy() method (not present in Java), support both val and var.
	          
	> Extenstion functions: 
	
	        - are designed to extend the functionality of final classes:
	        
	        	fun String.hidePassword() = "*".repeat(this.length)
	        	
	          'this' points to a string object the function is called on.
	          the compiler will transform this not in a function of the String class, but in a regular top-level function
	          
	          	fun hidePassword(this: String) = "*".repeat(this.length)
	          	
	        - the class being extending is called a 'method receiver'
	          	
	        - cannot override member functions of the method receiver, or access its private and protected properties
	        
	> Introduction to design patterns:
	
		- a design pattern is a proven way to solve a common problem
		- it's basically a language feature, not present in the langugae itself
		- relevant only to object-oriented langugages
		  


II. WORKING WITH CREATIONAL PATTERNS



III. UNDERSTANDING STRUCTURAL PATTERNS



IV. GETTING FAMILIAR WITH BEHAVIORAL PATTERNS






--------------------------------------------------------
REACTIVE AND CONCURRENT PATTERNS
--------------------------------------------------------









--------------------------------------------------------
PRACTICAL APPLICATION OF DESIGN PATTERNS
--------------------------------------------------------
