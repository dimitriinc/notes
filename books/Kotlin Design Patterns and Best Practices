-------------------------------------------------------
CLASSICAL PATTERNS
-------------------------------------------------------


I. GETTING STARTED WITH KOTLIN

	> Kotlin code structure:
	
		- functions doesn't have to be wrapped in a class (like in java), e.g. the main() can exist separately in a file.
		- no 'static' modifier - functions that don't have a state, can be just placed outside of a class
		- params in the main() are optional (in Java String[] args is obligatory)
		
	> Types:
	
		- a type-safe language
		- no distinction between primitive types and object types (in Java 'int' is memory-efficient, while Integer is more operational
		  with its methods, and is nullable). Kotlin's compiler optimizes the types on the run, not to lose the memory efficiency of a 
		  primitive.
		- Java's 'void' is called Unit
		- the type is inferred if not declared explicitly. once declared, the var cannot be assigned a value of a different type.
		
			val greeting: String = "Hello world"

		- mutable variables use the keyword 'var', immutable (aka values) use 'val'. val is preferred - it's easier to reason about the code
		  that way, especially in a concurrent code.
		- '==' is implicitly translated to equals() (in Java == stands for referential equality, not the equality of the values)
		- '===' is for the referential equality
		- if a function returns a value, you should declare its type in the signature, after the params
		
			fun getGreeting(): String {
				return "Hello world"
			}
			
		  if a function consists only of the return statement, you can omit the return type and the curly braces
		  
		  	fun getGreeting() = "Hello world"
		  	
	> Null safety:
	
		- in Java all object types a nullable -> NullPointerException being a big deal
		- in Kotlin types can be nullable (hold '?' after the type) and non-nullable (no '?'), the nullability of types is checked before 
		  compile time
		  
	> Data structures:
	
		- lists: ordered collection of elements of the same type, declared with the listOf()
		- sets: collection of unique elements, not indexed, setOf() return LinkedHashSet. use 'in' function to check the presence of an el
		- maps: collection of key-value pairs, keys are unique. a pair is created with the 'to' special function
		
			val movieBatmans = mapOf(
				"Batman Returns" to "Michael Keaton",
				"Batman Forever" to "Val Kilmer",
				"Batman & Robin" to "George Clooney"
			)
			
		  to access a value by its key, use the bracket notation
		- those are read-only collections, they all have mutable counterparts (e.g. mutableListOf()), where you can use such metods as add()
		- there is also Array<> (the type you pass into the angle brackets is called 'type argument'), used to provide args to the main()
		
			fun main(args: Array<String>) {}
			
		  also to call Java functions that require arrays as args, and while using the 'varargs' syntax.
		  the functionality is similar to lists
		  
	> Control flow:
	
		- 'if' is an expression in Kotlin (statement in Java), which helps us to reduce the amount of return statements and simplify the code
		- 'when' is an analog of 'switch' in Java, but more powerful. also an expression, use when there are multiple conditions.
		
	> Working with text:
	
		- string interpolation - insert a value of a var with $, expression with ${}
		- multiline strings - put them inside """ """, no need to escape quotes, use trimIndent() to get rid of whitespacees and tabs
		
	> Loops:
	
		- for-each - for (element in collection) {}
		- for - the classic 'for' loop in Kotlin is applied to ranges:
		
			for (el in 0..9) {}
			
		  the range is inclusive. you can replace the range operator with the 'until' function, it will be exclusive. to iterate i reverse,
		  replace 'until' with 'downTo' function. the functions like until and downTo are called 'infix call'
		- while - while (expression) {}
		
	> OOP:
	
		- no 'new' keyword, class instantiation: val player = Player()
		- classes can be bodyless
		- primary constructor is defined in parentheses after the class name:
		
			class Player(name: String) {}
			
		- if you add 'val' to the name member, a getter will be automatically generated, and you'll be able to access it via its name:
		
			println(player.name)
			
	          if you add 'var' a setter will be generated along with a getter.
	          a property can be moved inside the body, in this case an initial value must be provided.
	        - you might want to add some validation when setting a new value (i.e. the value can be only positive). to do this you need to declare
	          a custom setter:
	          
	          	class Player(val name: String) {
	          		var score: Int = 0
	          			set(value) {
	          				field = if (value >=0) value else 0
	          			}
	          	}
	          	
	          'value' stands for the new value provided, and 'field' stands for the current value of the property
	        - to provide a custom getter, the property must be declared in the body of the class:
	        
	        	class Player(name: String) {
	        		val name = name
	        			get() = field.toUpperCase()
	        	}
	        	
	        - interfaces are declared with the 'interface' keyword, implemented with a colon:
	        
	        	interface DiceRoller {
	        		fun rollDice(): Int
	        	}
	        	class Player(name: String) : DiceRoller {
	        		fun rollDice() = Random.nextInt(0, 6)
	        	}
	        	
	          interface support default functions, i.e. if a fun doesn't depend on any state, you can define its operation in the body inside
	          the interface.
	          interfaces can declare properties as well.
	        - abstract classes are interfaces that can hold a state. extended with a colon, round brackets after the name:
	        
	        	class Player(name: String) : Moveable(), DiceRoller {}
	        	
	        - by default properties, functions, as well as classes are public
	        - by default all classes are final, i.e. can't be inherited from. to make a class eligable for inheritance, declare it open by 
	          prefixing it with the 'open' modifier.
	        - in the same manner to make functions open to overriding by child classes, you must declare them with the 'open' modifier.
	          to override an open function a child class must use the 'override' keyword
	          private properties cannot be accessed by a child class, they need to be public or protected (visible to the class and its children)
	        - when extending a class (including an abstract class), we should provide data for its constructor (equivalent to calling the super()
	          in Java) 
	          
	          	class ConfusedPlayer(name: String) : Player(name) {}
	          	
	        - data classes replace POJOs of Java, automatically generate equals() and hashCode(). are always final (can't be extended), though
	          can inherit from other classes. have a copy() method (not present in Java), support both val and var.
	          
	> Extenstion functions: 
	
	        - are designed to extend the functionality of final classes:
	        
	        	fun String.hidePassword() = "*".repeat(this.length)
	        	
	          'this' points to a string object the function is called on.
	          the compiler will transform this not in a function of the String class, but in a regular top-level function
	          
	          	fun hidePassword(this: String) = "*".repeat(this.length)
	          	
	        - the class being extending is called a 'method receiver'
	          	
	        - cannot override member functions of the method receiver, or access its private and protected properties
	        
	> Introduction to design patterns:
	
		- a design pattern is a proven way to solve a common problem
		- it's basically a language feature, not present in the langugae itself
		- relevant only to object-oriented langugages
		  


II. WORKING WITH CREATIONAL PATTERNS

	> these patterns deal with how and when we create objects
	
	1. Singleton
	
		requirements:
			- creates only one instance of a class
			- this instance must be accessible from anywhere in the system
			- the instantiation should be lazy, i.e. only when we use it for the first time, not at the start of the programm
			- thread-safe: if two threads try to instantiate it simultaniously, they should get the same instance.
			- if many threads try to instantiate a singleton object at the same time, they shouldn't be blocked for a long time
			- cannot have a constructor, since it's not instantiated by us
			
		in Kotlin the implementation is easy - you just use the keyword 'object' instead of 'class'
		objects can implement interfaces
		if you want to run some op at initialization, put it inside the init{} block
		
			object Logger : SomeInterface {
				init {
					some op
				}
			}
			
		* we use the 'object' keyword also to create an anonymous object:
		
			view.setOnClickListener(object : OnClickListener {
				override fun onClick() {...}
			}
			
	2. Factory Method:
	
		used for creation of objects of the same category (implement the same interface) but with different implementations. the factory
		decides based on some factor which of implementations is needed, and creates that implementation.
		so the parts of the pattern are:
			- an interface, a blueprint for products
			- product classes, in our case - data classes that implement the interface 
			- creator function - accepts some differentiating factor as its argument, and based on it ('when' expression) returns an object 
			  of the resulting data class
			  
		* the data class that implements an interface with some declared properties must override them in its constructor:
		
			interface ChessPiece {
				val file: Char,
				val rank: Char
			}
			
			data class King(
				override val file: Char,
				override val rank: Char
			) : ChessPiece
			
		* you can extract components or properties from a collection or an object (of a data class) and assign them to individual variables
		  with destructuring declarations:
		  
		  	val notation = "qa5"
		  	val (type, file, rank) = notation.toCharArray()
		  	
	3. Static Factory Method:
	
		a class includes a static method that returns an instance of that class, a static constructor, so to speak.
		benefits:
			- you can have multiple named constructors with different implementation
			- you can implement an error-handling logic
			- you can return instances of this class' subclasses
			- descriptive name
			- encapsulation: hide the implementation of construction by making the constructor itself private, thus making the static 
			  factory method the only way to instantiate
			  
		Kotlin doesn't have a 'static' modifier, the way to create static fields and methods is through a 'companion object' - a class within
		the class that contains fields and methods accessible on the class itself, but not its instances
		
			class Server private constructor(port: Long) {
				init {
					println("server started on port $port")
				}
				companion object {
					fun withPort(port: Long) = Server(port)
				)
			}
			
	4. Abstract Factory:
	
		a factory is a class or a method that creates other classes. an abstract factory is a  class that wraps multiple factory methods.
		the Abstract Factory is commonly used in framewords and libraries that get their configuration from files.
		
		the Factory Method creates objects of sibling classes (implement the same interface), the Abstract Factory creates objects of family
		of related classes, not necessarily siblings
		
			* Any class is the root of class hierarchy (like Object in Java), if a class doesn't specify it's parent, it inherits from
			  Any by default. it's the Any that contains equals(), hashCode(), and toString()
			  
		so the goal is to create objects. those objects are implementation of concrete classes, and those concrete classes implement some 
		abstract product interface. in Abstract Factory we have multiple abstract product interfaces, and multiple factory methods or classes,
		one for each abstract product.
		for example, we receive the configuration of our system from a YAML config file, and in our code we want to parse this file, and
		create an object for each property. the YAML (YAML Ain't Markup Language) file:
		
			server: 
				port: 8000
			environment: production
			
		we'll have an interface for a property, each class that implements this interface will be a class for some concrete property (e.g. 
		port). we'll have another interface for the server configuration, which will contain a list of properties - related, not siblings.
		
			* Casting - a way to force compiler to use the specified type instead of the one it inferred. We can use the unsafe cast
			  if we positively sure of the type:
			  
			  	val port: Int = portProperty.value as Int
			
			  it's 'unsafe' because if the value is not of the declared type, the program will crash
			  a 'safe' cast returns null if the type is wrong, so the variable will be of a nullable type:
			  
			  	val port: Int? = portProperty.value as? Int
			  	
			  a smart cast is performed implicitly by the compiler when we do a type check. 
			  
			  	if (portProperty is IntProperty) {
			  		do sth
			  	}
			  	
			  it works with nullables as well: in Kotlin hierarchy the non-nullable type is a subclass of the nullable one
			  
			  	val port: Int? = 8080
			  	if (port != null) {
			  		do sth		// the 'port' is now of the Int type
			  	}
			  	
			* the reason we need a cast here is because in our Property implementation we have a 'value' field of Any type, since it can
			  be either number or a string, depending on he property. another solution is to subclass the Property into StringProperty
			  and IntProperty
			  
		and finally, the abstract factory class or interface wraps the factory methods responsible for creating products. one way to implement
		it, is to create a Static Factory Method for each factory inside a companion object of the abstract factory class:
		
			class AbstractFactory {
				companion object {
					fun porperty(prop: String): Property {...}
					fun server(propertyStrings: List<String>): ServerConfiguration {...}
				}
			}
			
		we could also make it as an interface with the factory methods as its functionality
		
	5. Builder:
	
		used for construction of complex objects that requires a lot of properties. it simplifies the task by separating construction (i.e. 
		assigning of arguments) from representation (i.e. creation of an object). thus, the pattern consists of two components: the product
		class and the builder class (also can be an interface, which will be implemented by several concrete builder classes, differing in the
		implementation details). the builder class contains functions for setting each of the properties, the function returns the builder
		itself to enable the chaining; and a build() function that creates a product object with those properties. the properties belong to 
		the Builder class itself, they duplicate the properties of the product class.
		
		in Kotlin the product class is a data class, that can be wrapped inside the builder class so it has a direct reference to it.
		
			* the comma that put after the last parameter is called a 'trailing coma', it's good for maintainability in case we change
			  those params later.
			* 'internal' modifier sets the visibility of the declaration (class, fun, property, or type) to the scope of its module
			* it's a convention to prefix private variables with underscore to make the assignments like 
			
				this._message = message
				
			  more readable.
			* to return the same object on which we perform an operation instead of doing it explicitly:
			
				fun message(msg: String): MailBuilder {
					this._message = msg
					return this
				}
				
			  we can use a scoping function 'apply', which can be called on any object in Kotlin. it introduces us into the scope of the 
			  object, and returns the object itself after executing its block:
			  
			  	fun message(msg: String) = apply {
			  		_message = msg
			  	}
			  	
		over all, the Builder is not much in use in Kotlin, because default and named args make it easy to create complex object without 
		implementing this design pattern.
		
	6. Prototype:
	
		for creating objects that are similar, but slightly different, e.g. they differ in the value of one property. the task is to save 
		resources and not to crate a whole new object, when mostly the new object is the same as the old one. the solution is to clone/copy the 
		old one, and implement such a cloning logic that would allow to update certain properties.
		the traditional way is with a Prototype interface that has a clone() method, which returns the Prototype itself (i.e. an object of the 
		class that implements the Prototype interface). then a class implements the interface and defines its own cloning logic.
		
		in Kotlin the DP is incorporated in the language itself in the form of the copy() method of data classes.
		
			* add elements to a collection with the plusAssign operator (+=)



III. UNDERSTANDING STRUCTURAL PATTERNS



IV. GETTING FAMILIAR WITH BEHAVIORAL PATTERNS






--------------------------------------------------------
REACTIVE AND CONCURRENT PATTERNS
--------------------------------------------------------









--------------------------------------------------------
PRACTICAL APPLICATION OF DESIGN PATTERNS
--------------------------------------------------------
