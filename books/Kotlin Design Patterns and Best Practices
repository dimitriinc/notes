-------------------------------------------------------
CLASSICAL PATTERNS
-------------------------------------------------------


I. GETTING STARTED WITH KOTLIN

	> Kotlin code structure:
	
		- functions doesn't have to be wrapped in a class (like in java), e.g. the main() can exist separately in a file.
		- no 'static' modifier - functions that don't have a state, can be just placed outside of a class
		- params in the main() are optional (in Java String[] args is obligatory)
		
	> Types:
	
		- a type-safe language
		- no distinction between primitive types and object types (in Java 'int' is memory-efficient, while Integer is more operational
		  with its methods, and is nullable). Kotlin's compiler optimizes the types on the run, not to lose the memory efficiency of a 
		  primitive.
		- Java's 'void' is called Unit
		- the type is inferred if not declared explicitly. once declared, the var cannot be assigned a value of a different type.
		
			val greeting: String = "Hello world"

		- mutable variables use the keyword 'var', immutable (aka values) use 'val'. val is preferred - it's easier to reason about the code
		  that way, especially in a concurrent code.
		- '==' is implicitly translated to equals() (in Java == stands for referential equality, not the equality of the values)
		- '===' is for the referential equality
		- if a function returns a value, you should declare its type in the signature, after the params
		
			fun getGreeting(): String {
				return "Hello world"
			}
			
		  if a function consists only of the return statement, you can omit the return type and the curly braces
		  
		  	fun getGreeting() = "Hello world"
		  	
	> Null safety:
	
		- in Java all object types a nullable -> NullPointerException being a big deal
		- in Kotlin types can be nullable (hold '?' after the type) and non-nullable (no '?'), the nullability of types is checked before 
		  compile time
		  
	> Data structures:
	
		- lists: ordered collection of elements of the same type, declared with the listOf()
		- sets: collection of unique elements, not indexed, setOf() return LinkedHashSet. use 'in' function to check the presence of an el
		- maps: collection of key-value pairs, keys are unique. a pair is created with the 'to' special function
		
			val movieBatmans = mapOf(
				"Batman Returns" to "Michael Keaton",
				"Batman Forever" to "Val Kilmer",
				"Batman & Robin" to "George Clooney"
			)
			
		  to access a value by its key, use the bracket notation
		- those are read-only collections, they all have mutable counterparts (e.g. mutableListOf()), where you can use such metods as add()
		- there is also Array<> (the type you pass into the angle brackets is called 'type argument'), used to provide args to the main()
		
			fun main(args: Array<String>) {}
			
		  also to call Java functions that require arrays as args, and while using the 'varargs' syntax.
		  the functionality is similar to lists
		  
	> Control flow:
	
		- 'if' is an expression in Kotlin (statement in Java), which helps us to reduce the amount of return statements and simplify the code
		- 'when' is an analog of 'switch' in Java, but more powerful. also an expression, use when there are multiple conditions.
		
	> Working with text:
	
		- string interpolation - insert a value of a var with $, expression with ${}
		- multiline strings - put them inside """ """, no need to escape quotes, use trimIndent() to get rid of whitespacees and tabs
		
	> Loops:
	
		- for-each - for (element in collection) {}
		- for - the classic 'for' loop in Kotlin is applied to ranges:
		
			for (el in 0..9) {}
			
		  the range is inclusive. you can replace the range operator with the 'until' function, it will be exclusive. to iterate i reverse,
		  replace 'until' with 'downTo' function. the functions like until and downTo are called 'infix call'
		- while - while (expression) {}
		
	> OOP:
	
		- no 'new' keyword, class instantiation: val player = Player()
		- classes can be bodyless
		- primary constructor is defined in parentheses after the class name:
		
			class Player(name: String) {}
			
		- if you add 'val' to the name member, a getter will be automatically generated, and you'll be able to access it via its name:
		
			println(player.name)
			
	          if you add 'var' a setter will be generated along with a getter.
	          a property can be moved inside the body, in this case an initial value must be provided.
	        - you might want to add some validation when setting a new value (i.e. the value can be only positive). to do this you need to declare
	          a custom setter:
	          
	          	class Player(val name: String) {
	          		var score: Int = 0
	          			set(value) {
	          				field = if (value >=0) value else 0
	          			}
	          	}
	          	
	          'value' stands for the new value provided, and 'field' stands for the current value of the property
	        - to provide a custom getter, the property must be declared in the body of the class:
	        
	        	class Player(name: String) {
	        		val name = name
	        			get() = field.toUpperCase()
	        	}
	        	
	        - interfaces are declared with the 'interface' keyword, implemented with a colon:
	        
	        	interface DiceRoller {
	        		fun rollDice(): Int
	        	}
	        	class Player(name: String) : DiceRoller {
	        		fun rollDice() = Random.nextInt(0, 6)
	        	}
	        	
	          interface support default functions, i.e. if a fun doesn't depend on any state, you can define its operation in the body inside
	          the interface.
	          interfaces can declare properties as well.
	        - abstract classes are interfaces that can hold a state. extended with a colon, round brackets after the name:
	        
	        	class Player(name: String) : Moveable(), DiceRoller {}
	        	
	        - by default properties, functions, as well as classes are public
	        - by default all classes are final, i.e. can't be inherited from. to make a class eligable for inheritance, declare it open by 
	          prefixing it with the 'open' modifier.
	        - in the same manner to make functions open to overriding by child classes, you must declare them with the 'open' modifier.
	          to override an open function a child class must use the 'override' keyword
	          private properties cannot be accessed by a child class, they need to be public or protected (visible to the class and its children)
	        - when extending a class (including an abstract class), we should provide data for its constructor (equivalent to calling the super()
	          in Java) 
	          
	          	class ConfusedPlayer(name: String) : Player(name) {}
	          	
	        - data classes replace POJOs of Java, automatically generate equals() and hashCode(). are always final (can't be extended), though
	          can inherit from other classes. have a copy() method (not present in Java), support both val and var.
	          
	> Extenstion functions: 
	
	        - are designed to extend the functionality of final classes:
	        
	        	fun String.hidePassword() = "*".repeat(this.length)
	        	
	          'this' points to a string object the function is called on.
	          the compiler will transform this not in a function of the String class, but in a regular top-level function
	          
	          	fun hidePassword(this: String) = "*".repeat(this.length)
	          	
	        - the class being extending is called a 'method receiver'
	          	
	        - cannot override member functions of the method receiver, or access its private and protected properties
	        
	> Introduction to design patterns:
	
		- a design pattern is a proven way to solve a common problem
		- it's basically a language feature, not present in the langugae itself
		- relevant only to object-oriented langugages
		  


II. WORKING WITH CREATIONAL PATTERNS

	> these patterns deal with how and when we create objects
	
	1. Singleton
	
		requirements:
			- creates only one instance of a class
			- this instance must be accessible from anywhere in the system
			- the instantiation should be lazy, i.e. only when we use it for the first time, not at the start of the programm
			- thread-safe: if two threads try to instantiate it simultaniously, they should get the same instance.
			- if many threads try to instantiate a singleton object at the same time, they shouldn't be blocked for a long time
			- cannot have a constructor, since it's not instantiated by us
			
		in Kotlin the implementation is easy - you just the keyword 'object' instead of 'class'
		objects can implement interfaces
		if you want to run some op at initialization, put it inside the init{} block
		
			object Logger : SomeInterface {
				init {
					some op
				}
			}
			
	2. Factory Method:
	
		used for creation of objects of the same category (implement the same interface) but with different implementations. the factory
		decides based on some factor which of implementations is needed, and creates that implementation.
		so the parts of the pattern are:
			- an interface, a blueprint for products
			- product classes, in our case - data classes that implement the interface 
			- creator function - accepts some differentiating factor as its argument, and based on it ('when' expression) returns an object 
			  of the resulting data class
			  
		* the data class that implements an interface with some declared properties must override them in its constructor:
		
			interface ChessPiece {
				val file: Char,
				val rank: Char
			}
			
			data class King(
				override val file: Char,
				override val rank: Char
			) : ChessPiece
			
		* you can extract components or properties from a collection or an object (of a data class) and assign them to individual variables
		  with destructuring declarations:
		  
		  	val notation = "qa5"
		  	val (type, file, rank) = notation.toCharArray()
		  	
	3. Static Factory Method:
	
		a class includes a static method that returns an instance of that class, a static constructor, so to speak.
		benefits:
			- you can have multiple named constructors with different implementation
			- you can implement an error-handling logic
			- you can return instances of this class' subclasses
			- descriptive name
			- encapsulation: hide the implementation of construction by making the constructor itself private, thus making the static 
			  factory method the only way to instantiate
			  
		Kotlin doesn't have a 'static' modifier, the way to create static fields and methods is through a 'companion object' - a class within
		the class that contains fields and methods accessible on the class itself, but not its instances
		
			class Server private constructor(port: Long) {
				init {
					println("server started on port $port")
				}
				companion object {
					fun withPort(port: Long) = Server(port)
				)
			}
			
	4. Abstract Factory:
	
		a factory is a class or a method that creates other classes. an abstract factory is a  class that wraps multiple factory methods.
		the Abstract Factory is commonly used in framewords and libraries that get their configuration from files.
		
		the Factory Method creates objects of sibling classes (implement the same interface), the Abstract Factory creates objects of family
		of related classes, not necessarily siblings
		
			* Any class is the root of class hierarchy (like Object in Java), if a class doesn't specify it's parent, it inherits from
			  Any by default. it's the Any that contains equals(), hashCode(), and toString()
			  
		so the goal is to create objects. those objects are implementation of concrete classes, and those concrete classes implement some 
		abstract interface. in Abstract Factory we have multiple abstract interfaces.
		for example, we receive the configuration of our system from a YAML config file, and in our code we want to parse this file, and
		create an object for each property. the YAML (YAML Ain't Markup Language) file:
		
			server: 
				port: 8000
			environment: production
			
		we'll have an interface for a property, each class that implements this interface will be a class for some concrete property (e.g. 
		port). we'll have another interface for the server configuration, which will contain a list of properties - related, not siblings.
		
			* Casting - a way to force compiler to use the specified type instead of the one it inferred. We can use the unsafe cast
			  if we positively sure of the type:
			  
			  	val port: Int = portProperty.value as Int
			
				



III. UNDERSTANDING STRUCTURAL PATTERNS



IV. GETTING FAMILIAR WITH BEHAVIORAL PATTERNS






--------------------------------------------------------
REACTIVE AND CONCURRENT PATTERNS
--------------------------------------------------------









--------------------------------------------------------
PRACTICAL APPLICATION OF DESIGN PATTERNS
--------------------------------------------------------
